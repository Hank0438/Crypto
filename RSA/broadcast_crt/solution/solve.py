from Crypto.Util.number import getPrime, isPrime, inverse 
import random
from functools import reduce
import gmpy2


def chinese_remainder(n, a):
    sum = 0
    prod = reduce(lambda x, y: x*y, n)  # product all
 
    for ni, ai in zip(n, a):
        p = prod // ni
        sum += ai * inverse(p, ni) * p
    return sum % prod

def main():
    N1 = 2354007378033605777350133059151154059510085172566182265216137752866431974408852963271199913721062616862569200625930792473
    N2 = 1255581675837858516472651889980886347043786143705204687472045187639541618250442805468074113987481524682891365167169486357
    N3 = 1168622629685883441808729873091043463346367292863768078035206263099072975792180484352073618215213154088252672703920840843
    e = 3
    c1 = 919666176056679739616978040837040145384222904829927766553796652662634986149998179254365034439686083045521229338720185458
    c2 = 359516650763630132447633594564772713076056722142752905744533224030167568313552335757735983812773216125407131185657685142
    c3 = 800071247341345688253220771242447373854551353504756809406443322255922318196193532861493289610719266157194836386199370698



    common = chinese_remainder([N1,N2,N3], [c1,c2,c3])
    decrypted_msg = int(gmpy2.iroot(common, e)[0])
    print(decrypted_msg.to_bytes(0x40, byteorder='big').strip(b'\x00'))


if __name__ == '__main__':
    main()