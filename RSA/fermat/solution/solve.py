import binascii
from gmpy2 import iroot

def xgcd(a, b):
    """
    Extented Euclid GCD algorithm.
    Return (x, y, g) : a * x + b * y = gcd(a, b) = g.
    """
    if a == 0: return 0, 1, b
    if b == 0: return 1, 0, a

    px, ppx = 0, 1
    py, ppy = 1, 0

    while b:
        q = a // b
        a, b = b, a % b
        x = ppx - q * px
        y = ppy - q * py
        ppx, px = px, x
        ppy, py = py, y

    return ppx, ppy, a

def invmod(a, n):
    """
    Return 1 / a (mod n).
    a and n must be co-primes.
    """
    if n < 2:
        raise ValueError("modulus must be greater than 1")

    x, y, g = xgcd(a, n)

    if g != 1:
        raise ValueError("no invmod for given @a and @n")
    else:
        return x % n

def nroot(x, n):
    """
    Return truncated n'th root of x.
    """
    if n < 0:
        raise ValueError("can't extract negative root")

    if n == 0:
        raise ValueError("can't extract zero root")

    sign = 1
    if x < 0:
        sign = -1
        x = -x
        if n % 2 == 0:
            raise ValueError("can't extract even root of negative")

    high = 1
    while high ** n <= x:
        high <<= 1

    low = high >> 1
    while low < high:
        mid = (low + high) >> 1
        mr = mid ** n
        if mr == x:
            return (mid, True)
        elif low < mid and mr < x:
            low = mid
        elif high > mid and mr > x:
            high = mid
        else :
            return (sign * mid, False)
    return (sign * (mid + 1) , False)


def fermat_factorization(N):
    a = iroot(N,2)[0]
    b2 = a*a - N
    b = iroot(N,2)[0]
    count = 0
    while b*b != b2:
        a = a + 1
        b2 = a*a - N
        b = iroot(b2,2)[0]
        count += 1
    p=a+b
    q=a-b
    return p, q

intToBytes = lambda x: binascii.unhexlify(hex(x)[2:])

e = 808690243
n1 = 2319948179669890597584072718308508309287776280231707157639059364765985050415020922632465768208714020173176551433921298809295244748880999359451988638554868868894731332467639035845013
n2 = 85865418408667172766221448656995458874267088711579996336604627729319498104518240931121314442171359035468324296199046411047835764859803253495698412761460383845951522577526709595595112761035179441446498843570467502154013873220593806000035090258899316584821426956486294930785987439377537801221019153321044692063772975415408564313045582563859114348240751536490638605113721687963383073440580034842125089324764289164171473885456983794447170768292210532122285450373626587896289532385250379038396866510358678276350793972733431932392509145515458195692188288000101452215123114443748972589460151454651385826109388971700210118954395105270177636112599560075334493476357191456796819570370739392916355540046063614078928081755363263787307
enc1 = 1379454165767747082297155438060027976861126166678675317842070119475904304862385051499649195375048309018193849336731008102861810522608878287662418435482366077564664595827052554127296
enc2 = 11133190341677581876051682824954129524645101680000796384723115474093884884826867188948775803125020315224071029822204048525334802461264826068848451813888620993517542731594796380961038523909391248179141989324215006800636534758498006491151807786452451426759612445640053700655318511142397486267621345306545403397175375402542847906711349380824018847266178579339166609723842872681335997306462196654979961002034305698960911093210657263811938470807158401667215991347809867365423957766343498396213658208439204973987868211213190484600592518326555305803084050756637496478355116684636109048291013853096493167448110702340775038318105604226731874862963394091459524144968267430823557176858019675669083454923738966146868930728533463796138


s,r = fermat_factorization(n1)

d1 = invmod(e,(r-1)*(s-1))
flag1 = intToBytes(pow(enc1,d1,n1))

p = r**4 + r**3 + r**2 + r +1
q = n2 // p 

assert n2 == p*q

d2 = invmod(e,(p-1)*(q-1))
flag2 = intToBytes(pow(enc2,d2,n2))

print(flag1+flag2)