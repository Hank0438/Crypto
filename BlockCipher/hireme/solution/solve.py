
SBox = [
0xac,0xd1,0x25,0x94,0x1f,0xb3,0x33,0x28,0x7c,0x2b,0x17,0xbc,0xf6,0xb0,0x55,0x5d,
0x8f,0xd2,0x48,0xd4,0xd3,0x78,0x62,0x1a,0x02,0xf2,0x01,0xc9,0xaa,0xf0,0x83,0x71,
0x72,0x4b,0x6a,0xe8,0xe9,0x42,0xc0,0x53,0x63,0x66,0x13,0x4a,0xc1,0x85,0xcf,0x0c,
0x24,0x76,0xa5,0x6e,0xd7,0xa1,0xec,0xc6,0x04,0xc2,0xa2,0x5c,0x81,0x92,0x6c,0xda,
0xc6,0x86,0xba,0x4d,0x39,0xa0,0x0e,0x8c,0x8a,0xd0,0xfe,0x59,0x96,0x49,0xe6,0xea,
0x69,0x30,0x52,0x1c,0xe0,0xb2,0x05,0x9b,0x10,0x03,0xa8,0x64,0x51,0x97,0x02,0x09,
0x8e,0xad,0xf7,0x36,0x47,0xab,0xce,0x7f,0x56,0xca,0x00,0xe3,0xed,0xf1,0x38,0xd8,
0x26,0x1c,0xdc,0x35,0x91,0x43,0x2c,0x74,0xb4,0x61,0x9d,0x5e,0xe9,0x4c,0xbf,0x77,
0x16,0x1e,0x21,0x1d,0x2d,0xa9,0x95,0xb8,0xc3,0x8d,0xf8,0xdb,0x34,0xe1,0x84,0xd6,
0x0b,0x23,0x4e,0xff,0x3c,0x54,0xa7,0x78,0xa4,0x89,0x33,0x6d,0xfb,0x79,0x27,0xc4,
0xf9,0x40,0x41,0xdf,0xc5,0x82,0x93,0xdd,0xa6,0xef,0xcd,0x8d,0xa3,0xae,0x7a,0xb6,
0x2f,0xfd,0xbd,0xe5,0x98,0x66,0xf3,0x4f,0x57,0x88,0x90,0x9c,0x0a,0x50,0xe7,0x15,
0x7b,0x58,0xbc,0x07,0x68,0x3a,0x5f,0xee,0x32,0x9f,0xeb,0xcc,0x18,0x8b,0xe2,0x57,
0xb7,0x49,0x37,0xde,0xf5,0x99,0x67,0x5b,0x3b,0xbb,0x3d,0xb5,0x2d,0x19,0x2e,0x0d,
0x93,0xfc,0x7e,0x06,0x08,0xbe,0x3f,0xd9,0x2a,0x70,0x9a,0xc8,0x7d,0xd8,0x46,0x65,
0x22,0xf4,0xb9,0xa2,0x6f,0x12,0x1b,0x14,0x45,0xc7,0x87,0x31,0x60,0x29,0xf7,0x73,
0x2c,0x97,0x72,0xcd,0x89,0xa6,0x88,0x4c,0xe8,0x83,0xeb,0x59,0xca,0x50,0x3f,0x27,
0x4e,0xae,0x43,0xd5,0x6e,0xd0,0x99,0x7b,0x7c,0x40,0x0c,0x52,0x86,0xc1,0x46,0x12,
0x5a,0x28,0xa8,0xbb,0xcb,0xf0,0x11,0x95,0x26,0x0d,0x34,0x66,0x22,0x18,0x6f,0x51,
0x9b,0x3b,0xda,0xec,0x5e,0x00,0x2a,0xf5,0x8f,0x61,0xba,0x96,0xb3,0xd1,0x30,0xdc,
0x33,0x75,0xe9,0x6d,0xc8,0xa1,0x3a,0x3e,0x5f,0x9d,0xfd,0xa9,0x31,0x9f,0xaa,0x85,
0x2f,0x92,0xaf,0x67,0x78,0xa5,0xab,0x03,0x21,0x4f,0xb9,0xad,0xfe,0xf3,0x42,0xfc,
0x17,0xd7,0xee,0xa3,0xd8,0x80,0x14,0x2e,0xa0,0x47,0x55,0xc4,0xff,0xe5,0x13,0x3f,
0x81,0xb6,0x7a,0x94,0xd0,0xb5,0x54,0xbf,0x91,0xa7,0x37,0xf1,0x6b,0xc9,0x1b,0xb1,
0x3c,0xb6,0xd9,0x32,0x24,0x8d,0xf2,0x82,0xb4,0xf9,0xdb,0x7d,0x44,0xfb,0x1e,0xd4,
0xea,0x5d,0x35,0x69,0x23,0x71,0x57,0x01,0x06,0xe4,0x55,0x9a,0xa4,0x58,0x56,0xc7,
0x4a,0x8c,0x8a,0xd6,0x6a,0x49,0x70,0xc5,0x8e,0x0a,0x62,0xdc,0x29,0x4b,0x42,0x41,
0xcb,0x2b,0xb7,0xce,0x08,0xa1,0x76,0x1d,0x1a,0xb8,0xe3,0xcc,0x7e,0x48,0x20,0xe6,
0xf8,0x45,0x93,0xde,0xc3,0x63,0x0f,0xb0,0xac,0x5c,0xba,0xdf,0x07,0x77,0xe7,0x4e,
0x1f,0x28,0x10,0x6c,0x59,0xd3,0xdd,0x2d,0x65,0x39,0xb2,0x74,0x84,0x3d,0xf4,0xbd,
0xc7,0x79,0x60,0x0b,0x4d,0x33,0x36,0x25,0xbc,0xe0,0x09,0xcf,0x5b,0xe2,0x38,0x9e,
0xc0,0xef,0xd2,0x16,0x05,0xbe,0x53,0xf7,0xc2,0xc6,0xa2,0x24,0x98,0x1c,0xad,0x04
]
assert(len(SBox)==512)

PBox = [
0xf26cb481,0x16a5dc92,0x3c5ba924,0x79b65248,0x2fc64b18,0x615acd29,0xc3b59a42,0x976b2584,
0x6cf281b4,0xa51692dc,0x5b3c24a9,0xb6794852,0xc62f184b,0x5a6129cd,0xb5c3429a,0x6b978425,
0xb481f26c,0xdc9216a5,0xa9243c5b,0x524879b6,0x4b182fc6,0xcd29615a,0x9a42c3b5,0x2584976b,
0x81b46cf2,0x92dca516,0x24a95b3c,0x4852b679,0x184bc62f,0x29cd5a61,0x429ab5c3,0x84256b97
]
assert(len(PBox)==32)



'''
The solutions to this challenge belong to different levels :

Level 1 : an iterative algorithm which typically takes more than a second to
find a solution (for any given output). 

Most people stop here, which is fine, but if you want to go further, there is :

Level 2 : a non-iterative algorithm which typically takes less than a
millisecond to find a solution (for any given output).

Few people have reached this level. But if you want to beat it completely,
there's yet another castle...

Level 3 : an algorithm which can provide any of the 2^128 solutions (for any
given output).

Even fewer people have reached this final level. Congratulations to them!
'''

def Forward(c, d, s, p):
    for _ in range(256):
        
        for j in range(32):
            d[j] = s[c[j]]
            c[j] = 0
            
        for j in range(32):
            for k in range(32):
                c[j] ^= d[k] * ((p[j]>>k)&1)
                
    for i in range(16):
        d[i] = s[c[i*2]] ^ s[c[i*2+1]+256]

def ForwardUpperInternalUpper(c, d, s, p):
    for j in range(32):
        d[j] = s[c[j]]
        c[j] = 0

def ForwardUpperInternalLower(c, d, s, p):
    for j in range(32):
        for k in range(32):
            c[j] ^= d[k] * ((p[j]>>k)&1)

    
    # for k in range(32):
    #     c[0] ^= d[k] * ((p[0]>>k)&1)
    #     c[1] ^= d[k] * ((p[1]>>k)&1)
    #     c[2] ^= d[k] * ((p[2]>>k)&1)
    #     c[3] ^= d[k] * ((p[3]>>k)&1)
    #     c[4] ^= d[k] * ((p[4]>>k)&1)



def ForwardLower(c, d, s, p):
    for i in range(16):
        d[i] = s[c[i*2]] ^ s[c[i*2+1]+256]

def BackwardUpperInternalLower(c, d, s, p):
    for j in range(32):
        c_tmp = 0
        print(f"p[{j}]: {bin(p[j])}")
        for k in range(32):
            c_tmp ^= d[k] * ((p[j]>>k)&1)
        c[j] ^= c_tmp
        assert(c[j] == 0)

def BackwardUpperInternalUpper(c, d, s, p):
    combination = 1
    for j in range(32):
        candidate = []
        for idx, val in enumerate(s):
            if idx >= 256:
                break
            if d[j] == val:
                candidate.append(idx)
            
        combination *= len(candidate)
        c[j] = candidate[0]
    print("combination: ", combination)

InvSBox1 = [[]] * 256
InvSBox2 = [[]] * 256
Hole1 = []
Hole2 = []


def GenInverseSBox():
    for j in range(0, 256):
        candidate = []
        for idx, val in enumerate(SBox[0:256]):
            if j == val:
                candidate.append(idx)
        if len(candidate) == 0:
            Hole1.append(j)
        InvSBox1[j] = candidate

    
    for j in range(0, 256):
        candidate = []
        for idx, val in enumerate(SBox[256:512]):
            if j == val:
                candidate.append(idx)
        if len(candidate) == 0:
            Hole2.append(j)
        InvSBox2[j] = candidate

    # print(f"InvSBox1: {InvSBox1}")
    # print(f"InvSBox2: {InvSBox2}")
    print(f"Hole1: {Hole1}")
    print(f"Hole2: {Hole2}")



def BackwardLower(c, d, s, p):
    pass

def Backward(c, d, s, p):
    # d[0]~d[15] are fixed to output 
    # d[16]~d[31] are controlable
    pass
    d = b'HIREME~~123456~~\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f'



    ### solve equation
    ### PBox is not full-rank, so there must be mutiple solution from output[16:31], it make sense!
    ### c[0] = d[0]*{0,1} ^ d[1]*{0,1} ^ d[2]*{0,1} ^...^ d[31]*{0,1}
    ###      = b'H'*{0,1} ^ b'I'*{0,1} ^ b'R'*{0,1} ^...^ d[31]*{0,1}
    ###      = b'H'*p[0][32] ^ b'I'*p[0][31] ^ b'R'*p[0][30] ^...^ d[31]*p[0][0]
    ### s1[c[0]] ^ s2[c[1]] == d[0] == b'H'
    ### s1[c[2]] ^ s2[c[3]] == d[1] == b'I'

 
    for j in range(32):
        c_tmp = 0
        print(f"p[{j}]: {bin(p[j])}")
        # for k in range(0, 16):
        #     * ((p[j]>>k)&1)
        for k in range(16, 32):
            c_tmp ^= d[k] * ((p[j]>>k)&1)
        c[j] ^= c_tmp
        assert(c[j] == 0)


_input = [
    0x66,0xd5,0x4e,0x28,0x5f,0xff,0x6b,0x53,0xac,0x3b,0x34,0x14,0xb5,0x3c,0xb2,0xc6,
    0xa4,0x85,0x1e,0x0d,0x86,0xc7,0x4f,0xba,0x75,0x5e,0xcb,0xc3,0x6e,0x48,0x79,0x8f,
]
assert(len(_input)==32)

def main():
    target = b"Hire me!!!!!!!!"
    _output = [0]*32
    Forward(_input, _output, SBox, PBox)
    print("[+] _output: ", _output)  # 527672656d206174301b706859322adfe0affc0015c4f50000b326e0
        
        
    # if (output == target):
    #     print("[+] Good Job")
    # else:
    #     print("[-] QAQ")

def poc1():
    _output = [0]*32
    # ForwardUpper(_input, _output, SBox, PBox)
    for _ in range(256):
        ForwardUpperInternalUpper(_input, _output, SBox, PBox)
        print("[+] _output1: ", _output)
        ForwardUpperInternalLower(_input, _output, SBox, PBox)
        print("[+] _output2: ", _output)

    ForwardLower(_input, _output, SBox, PBox)
    print("[+] _output: ", _output)

def poc2():
    _output = [0]*32
    
    print("[+] _input: ", _input)

    ForwardUpperInternalUpper(_input, _output, SBox, PBox)
    print("[+] _output1: ", _output)
    print("[+] _input1: ", _input)
    
    ForwardUpperInternalLower(_input, _output, SBox, PBox)
    print("[+] _output2: ", _output)
    print("[+] _input2: ", _input)

    # ForwardLower(_input, _output, SBox, PBox)
    # print("[+] _output3: ", _output)
    # print("[+] _input3: ", _input)
    
    print("="*30)
    
    BackwardUpperInternalLower(_input, _output, SBox, PBox)
    print("[+] _output5: ", _output)
    print("[+] _input5: ", _input)
    
    BackwardUpperInternalUpper(_input, _output, SBox, PBox)
    print("[+] _output6: ", _output)
    print("[+] _input6: ", _input)



if __name__ == "__main__":
    import numpy as np
    target = b"Hire me!!!!!!!!"
    GenInverseSBox()
    s1 = np.array(SBox[0:256])
    s2 = np.array(SBox[256:512])
    SearchBox = np.bitwise_xor(s1.reshape((256,1)), s2)
    
    print(SearchBox.shape)
    SearchResult = []
    # for i in target:
    result = np.where(SearchBox == 72)
    SearchResult.append(result)
    print(f"SearchResult: {SearchResult}")
    # col = SearchResult[0][0]
    # row = SearchResult[0][1]
    # for x,y in zip(col, row):
    #     print(SearchBox[x][y])

    test = np.bitwise_xor([[31],[3],[7],[7]], [11,5,6,6])
    print(test)
    print(np.where(test == 1))
    col, row = np.where(test == 1)
    for x,y in zip(col, row):
        print(test[x][y])
    

    print(np.bitwise_xor(np.array([31,3]).reshape((2,1)), np.array([5,6])))




